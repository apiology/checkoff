# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rugged` gem.
# Please instead update this file by running `bin/tapioca gem rugged`.


# source://rugged//lib/rugged/index.rb#6
module Rugged
  private

  def __cache_usage__; end
  def dotgit_attributes?(_arg0); end
  def dotgit_ignore?(_arg0); end
  def dotgit_modules?(_arg0); end
  def features; end
  def hex_to_raw(_arg0); end
  def libgit2_prerelease; end
  def libgit2_version; end
  def minimize_oid(*_arg0); end
  def prettify_message(*_arg0); end
  def raw_to_hex(_arg0); end
  def signature_from_buffer(*_arg0); end
  def valid_full_oid?(_arg0); end

  class << self
    def __cache_usage__; end
    def dotgit_attributes?(_arg0); end
    def dotgit_ignore?(_arg0); end
    def dotgit_modules?(_arg0); end
    def features; end
    def hex_to_raw(_arg0); end
    def libgit2_prerelease; end
    def libgit2_version; end
    def minimize_oid(*_arg0); end
    def prettify_message(*_arg0); end
    def raw_to_hex(_arg0); end
    def signature_from_buffer(*_arg0); end
    def valid_full_oid?(_arg0); end
  end
end

class Rugged::Backend; end

class Rugged::Blame
  include ::Enumerable

  def [](_arg0); end
  def count; end
  def each; end
  def for_line(_arg0); end
  def size; end

  class << self
    def new(*_arg0); end
  end
end

# source://rugged//lib/rugged/blob.rb#7
class Rugged::Blob < ::Rugged::Object
  def binary?; end
  def content(*_arg0); end
  def diff(*_arg0); end

  # source://rugged//lib/rugged/blob.rb#14
  def hashsig(options = T.unsafe(nil)); end

  def loc; end

  # source://rugged//lib/rugged/blob.rb#18
  def similarity(other); end

  def size; end
  def sloc; end
  def text(*_arg0); end

  class << self
    def from_buffer(_arg0, _arg1); end
    def from_disk(_arg0, _arg1); end
    def from_io(*_arg0); end
    def from_workdir(_arg0, _arg1); end
    def merge_files(*_arg0); end
    def to_buffer(*_arg0); end
  end
end

# source://rugged//lib/rugged/blob.rb#8
class Rugged::Blob::HashSignature
  class << self
    def compare(_arg0, _arg1); end
    def new(*_arg0); end
  end
end

# source://rugged//lib/rugged/blob.rb#9
Rugged::Blob::HashSignature::WHITESPACE_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://rugged//lib/rugged/blob.rb#10
Rugged::Blob::HashSignature::WHITESPACE_IGNORE = T.let(T.unsafe(nil), Integer)

# source://rugged//lib/rugged/blob.rb#11
Rugged::Blob::HashSignature::WHITESPACE_SMART = T.let(T.unsafe(nil), Integer)

# source://rugged//lib/rugged/branch.rb#7
class Rugged::Branch < ::Rugged::Reference
  # source://rugged//lib/rugged/branch.rb#8
  def ==(other); end

  def head?; end
  def name; end

  # Get the remote the branch belongs to.
  #
  # If the branch is remote returns the remote it belongs to.
  # In case of local branch, it returns the remote of the branch
  # it tracks or nil if there is no tracking branch.
  #
  # source://rugged//lib/rugged/branch.rb#19
  def remote; end

  def remote_name; end
  def upstream; end
  def upstream=(_arg0); end
end

class Rugged::BranchCollection
  include ::Enumerable

  def initialize(_arg0); end

  def [](_arg0); end
  def create(*_arg0); end
  def delete(_arg0); end
  def each(*_arg0); end
  def each_name(*_arg0); end
  def exist?(_arg0); end
  def exists?(_arg0); end
  def move(*_arg0); end
  def rename(*_arg0); end
end

class Rugged::CallbackError < ::Rugged::Error; end
class Rugged::CheckoutError < ::Rugged::Error; end
class Rugged::CherrypickError < ::Rugged::Error; end

# source://rugged//lib/rugged/commit.rb#7
class Rugged::Commit < ::Rugged::Object
  def amend(_arg0); end
  def author; end
  def committer; end

  # Return a diff between this commit and its first parent or another commit or tree.
  #
  # The commit is treated as the new side of the diff by default
  #
  # See Rugged::Tree#diff for more details.
  #
  # source://rugged//lib/rugged/commit.rb#25
  def diff(*args); end

  # Return a diff between this commit and the workdir.
  #
  # See Rugged::Tree#diff_workdir for more details.
  #
  # source://rugged//lib/rugged/commit.rb#45
  def diff_workdir(options = T.unsafe(nil)); end

  def epoch_time; end
  def header; end
  def header_field(_arg0); end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/commit.rb#16
  def header_field?(field); end

  # source://rugged//lib/rugged/commit.rb#12
  def inspect; end

  def message; end

  # source://rugged//lib/rugged/commit.rb#67
  def modify(new_args, update_ref = T.unsafe(nil)); end

  def parent_ids; end
  def parent_oids; end
  def parents; end
  def summary; end

  # The time when this commit was made effective. This is the same value
  # as the +:time+ attribute for +commit.committer+.
  #
  # Returns a Time object
  #
  # source://rugged//lib/rugged/commit.rb#53
  def time; end

  # source://rugged//lib/rugged/commit.rb#57
  def to_hash; end

  def to_mbox(*_arg0); end
  def trailers; end
  def tree; end
  def tree_id; end
  def tree_oid; end

  class << self
    def create(_arg0, _arg1); end
    def create_to_s(_arg0, _arg1); end
    def create_with_signature(*_arg0); end
    def extract_signature(*_arg0); end

    # source://rugged//lib/rugged/commit.rb#8
    def prettify_message(msg, strip_comments = T.unsafe(nil)); end
  end
end

class Rugged::Config
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def delete(_arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def get(_arg0); end
  def get_all(_arg0); end
  def snapshot; end
  def store(_arg0, _arg1); end
  def to_hash; end
  def transaction; end

  class << self
    def global; end
    def new(_arg0); end
    def open_global; end
  end
end

class Rugged::ConfigError < ::Rugged::Error; end

# source://rugged//lib/rugged/credentials.rb#7
module Rugged::Credentials; end

# A "default" credential usable for Negotiate mechanisms like NTLM or
# Kerberos authentication
#
# source://rugged//lib/rugged/credentials.rb#42
class Rugged::Credentials::Default
  # source://rugged//lib/rugged/credentials.rb#43
  def call(url, username_from_url, allowed_types); end
end

# A ssh key credential object that can optionally be passphrase-protected
#
# source://rugged//lib/rugged/credentials.rb#20
class Rugged::Credentials::SshKey
  # @return [SshKey] a new instance of SshKey
  #
  # source://rugged//lib/rugged/credentials.rb#21
  def initialize(options); end

  # source://rugged//lib/rugged/credentials.rb#25
  def call(url, username_from_url, allowed_types); end
end

# source://rugged//lib/rugged/credentials.rb#30
class Rugged::Credentials::SshKeyFromAgent
  # @return [SshKeyFromAgent] a new instance of SshKeyFromAgent
  #
  # source://rugged//lib/rugged/credentials.rb#31
  def initialize(options); end

  # source://rugged//lib/rugged/credentials.rb#35
  def call(url, username_from_url, allowed_types); end
end

# A plain-text username and password credential object.
#
# source://rugged//lib/rugged/credentials.rb#9
class Rugged::Credentials::UserPassword
  # @return [UserPassword] a new instance of UserPassword
  #
  # source://rugged//lib/rugged/credentials.rb#10
  def initialize(options); end

  # source://rugged//lib/rugged/credentials.rb#14
  def call(url, username_from_url, allowed_types); end
end

class Rugged::DescribeError < ::Rugged::Error; end

# source://rugged//lib/rugged/diff/hunk.rb#7
class Rugged::Diff
  include ::Enumerable

  # source://rugged//lib/rugged/diff.rb#21
  def deltas; end

  def each; end
  def each_delta; end
  def each_line(*_arg0); end
  def each_patch; end
  def find_similar!(*_arg0); end
  def merge!(_arg0); end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/diff.rb#15
  def owner; end

  def patch(*_arg0); end

  # source://rugged//lib/rugged/diff.rb#17
  def patches; end

  def size; end
  def sorted_icase?; end
  def stat; end
  def write_patch(*_arg0); end
end

# source://rugged//lib/rugged/diff/delta.rb#8
class Rugged::Diff::Delta
  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#21
  def added?; end

  # Returns the value of attribute binary.
  #
  # source://rugged//lib/rugged/diff/delta.rb#17
  def binary; end

  # Returns the value of attribute binary.
  #
  # source://rugged//lib/rugged/diff/delta.rb#17
  def binary?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#37
  def copied?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#25
  def deleted?; end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/diff/delta.rb#9
  def diff; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#41
  def ignored?; end

  # source://rugged//lib/rugged/diff/delta.rb#53
  def inspect; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#29
  def modified?; end

  # Returns the value of attribute new_file.
  #
  # source://rugged//lib/rugged/diff/delta.rb#13
  def new_file; end

  # Returns the value of attribute old_file.
  #
  # source://rugged//lib/rugged/diff/delta.rb#12
  def old_file; end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/diff/delta.rb#9
  def owner; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#33
  def renamed?; end

  # Returns the value of attribute similarity.
  #
  # source://rugged//lib/rugged/diff/delta.rb#14
  def similarity; end

  # Returns the value of attribute status.
  #
  # source://rugged//lib/rugged/diff/delta.rb#15
  def status; end

  # Returns the value of attribute status_char.
  #
  # source://rugged//lib/rugged/diff/delta.rb#16
  def status_char; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#49
  def typechange?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/delta.rb#45
  def untracked?; end
end

# source://rugged//lib/rugged/diff/hunk.rb#8
class Rugged::Diff::Hunk
  include ::Enumerable

  def count; end

  # source://rugged//lib/rugged/diff/hunk.rb#9
  def delta; end

  def each; end
  def each_line; end
  def header; end
  def hunk_index; end

  # source://rugged//lib/rugged/diff/hunk.rb#13
  def inspect; end

  def line_count; end

  # Returns an Array containing all lines of the hunk.
  #
  # source://rugged//lib/rugged/diff/hunk.rb#18
  def lines; end

  def new_lines; end
  def new_start; end
  def old_lines; end
  def old_start; end
  def size; end
end

# source://rugged//lib/rugged/diff/line.rb#8
class Rugged::Diff::Line
  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#15
  def addition?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#43
  def binary?; end

  # Returns the value of attribute content.
  #
  # source://rugged//lib/rugged/diff/line.rb#9
  def content; end

  # Returns the value of attribute content_offset.
  #
  # source://rugged//lib/rugged/diff/line.rb#9
  def content_offset; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#11
  def context?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#19
  def deletion?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#27
  def eof_newline_added?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#31
  def eof_newline_removed?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#23
  def eof_no_newline?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#35
  def file_header?; end

  # @return [Boolean]
  #
  # source://rugged//lib/rugged/diff/line.rb#39
  def hunk_header?; end

  # source://rugged//lib/rugged/diff/line.rb#47
  def inspect; end

  # Returns the value of attribute line_origin.
  #
  # source://rugged//lib/rugged/diff/line.rb#9
  def line_origin; end

  # Returns the value of attribute new_lineno.
  #
  # source://rugged//lib/rugged/diff/line.rb#9
  def new_lineno; end

  # Returns the value of attribute old_lineno.
  #
  # source://rugged//lib/rugged/diff/line.rb#9
  def old_lineno; end
end

class Rugged::Error < ::StandardError; end
class Rugged::FetchheadError < ::Rugged::Error; end
class Rugged::FilesystemError < ::Rugged::Error; end
class Rugged::FilterError < ::Rugged::Error; end
class Rugged::HTTPError < ::Rugged::Error; end

# source://rugged//lib/rugged/index.rb#7
class Rugged::Index
  include ::Enumerable

  def <<(_arg0); end
  def [](*_arg0); end
  def add(_arg0); end
  def add_all(*_arg0); end
  def clear; end
  def conflict_add(_arg0); end
  def conflict_cleanup; end
  def conflict_get(_arg0); end
  def conflict_remove(_arg0); end
  def conflicts; end
  def conflicts?; end
  def count; end

  # call-seq:
  #   index.diff([options]) -> diff
  #   index.diff(diffable[, options]) -> diff
  #
  # The first form returns a diff between the index and the current working
  # directory.
  #
  # The second form returns a diff between the index and the given diffable object.
  # +diffable+ can either be a +Rugged::Commit+ or a +Rugged::Tree+.
  #
  # The index will be used as the "old file" side of the diff, while the working
  # directory or the +diffable+ will be used for the "new file" side.
  #
  # The following options can be passed in the +options+ Hash:
  #
  # :paths ::
  #   An array of paths / fnmatch patterns to constrain the diff to a specific
  #   set of files. Also see +:disable_pathspec_match+.
  #
  # :max_size ::
  #   An integer specifying the maximum byte size of a file before a it will
  #   be treated as binary. The default value is 512MB.
  #
  # :context_lines ::
  #   The number of unchanged lines that define the boundary of a hunk (and
  #   to display before and after the actual changes). The default is 3.
  #
  # :interhunk_lines ::
  #   The maximum number of unchanged lines between hunk boundaries before the hunks
  #   will be merged into a one. The default is 0.
  #
  # :reverse ::
  #   If true, the sides of the diff will be reversed.
  #
  # :force_text ::
  #   If true, all files will be treated as text, disabling binary attributes & detection.
  #
  # :ignore_whitespace ::
  #   If true, all whitespace will be ignored.
  #
  # :ignore_whitespace_change ::
  #   If true, changes in amount of whitespace will be ignored.
  #
  # :ignore_whitespace_eol ::
  #   If true, whitespace at end of line will be ignored.
  #
  # :ignore_submodules ::
  #   if true, submodules will be excluded from the diff completely.
  #
  # :patience ::
  #   If true, the "patience diff" algorithm will be used (currenlty unimplemented).
  #
  # :include_ignored ::
  #   If true, ignored files will be included in the diff.
  #
  # :include_untracked ::
  #  If true, untracked files will be included in the diff.
  #
  # :include_unmodified ::
  #   If true, unmodified files will be included in the diff.
  #
  # :recurse_untracked_dirs ::
  #   Even if +:include_untracked+ is true, untracked directories will only be
  #   marked with a single entry in the diff. If this flag is set to true,
  #   all files under ignored directories will be included in the diff, too.
  #
  # :disable_pathspec_match ::
  #   If true, the given +:paths+ will be applied as exact matches, instead of
  #   as fnmatch patterns.
  #
  # :deltas_are_icase ::
  #   If true, filename comparisons will be made with case-insensitivity.
  #
  # :show_untracked_content ::
  #   if true, untracked content will be contained in the the diff patch text.
  #
  # :skip_binary_check ::
  #   If true, diff deltas will be generated without spending time on binary
  #   detection. This is useful to improve performance in cases where the actual
  #   file content difference is not needed.
  #
  # :include_typechange ::
  #   If true, type changes for files will not be interpreted as deletion of
  #   the "old file" and addition of the "new file", but will generate
  #   typechange records.
  #
  # :include_typechange_trees ::
  #   Even if +:include_typechange+ is true, blob -> tree changes will still
  #   usually be handled as a deletion of the blob. If this flag is set to true,
  #   blob -> tree changes will be marked as typechanges.
  #
  # :ignore_filemode ::
  #   If true, file mode changes will be ignored.
  #
  # :recurse_ignored_dirs ::
  #   Even if +:include_ignored+ is true, ignored directories will only be
  #   marked with a single entry in the diff. If this flag is set to true,
  #   all files under ignored directories will be included in the diff, too.
  #
  # source://rugged//lib/rugged/index.rb#109
  def diff(*args); end

  def each; end
  def get(*_arg0); end
  def merge_file(*_arg0); end
  def read_tree(_arg0); end
  def reload; end
  def remove(*_arg0); end
  def remove_all(*_arg0); end
  def remove_dir(*_arg0); end

  # source://rugged//lib/rugged/index.rb#125
  def to_s; end

  def update(_arg0); end
  def update_all(*_arg0); end
  def write; end
  def write_tree(*_arg0); end

  private

  def diff_index_to_workdir(_arg0); end
  def diff_tree_to_index(_arg0, _arg1); end

  class << self
    def new(*_arg0); end
  end
end

Rugged::Index::ENTRY_FLAGS_STAGE = T.let(T.unsafe(nil), Integer)
Rugged::Index::ENTRY_FLAGS_STAGE_SHIFT = T.let(T.unsafe(nil), Integer)
Rugged::Index::ENTRY_FLAGS_VALID = T.let(T.unsafe(nil), Integer)
class Rugged::IndexError < ::Rugged::Error; end
class Rugged::IndexerError < ::Rugged::Error; end
class Rugged::InvalidError < ::ArgumentError; end
class Rugged::MergeError < ::Rugged::Error; end
class Rugged::NetworkError < ::Rugged::Error; end
class Rugged::NoMemError < ::NoMemoryError; end
class Rugged::OSError < ::IOError; end

# source://rugged//lib/rugged/object.rb#7
class Rugged::Object
  # source://rugged//lib/rugged/object.rb#8
  def <=>(other); end

  def ==(_arg0); end
  def create_note(_arg0); end
  def notes(*_arg0); end
  def oid; end
  def read_raw; end
  def remove_note(*_arg0); end
  def type; end

  class << self
    def lookup(_arg0, _arg1); end
    def new(_arg0, _arg1); end
    def rev_parse(_arg0, _arg1); end
    def rev_parse_oid(_arg0, _arg1); end
  end
end

class Rugged::ObjectError < ::Rugged::Error; end
class Rugged::OdbError < ::Rugged::Error; end

class Rugged::OdbObject
  def data; end
  def len; end
  def oid; end
  def type; end
end

# source://rugged//lib/rugged/patch.rb#7
class Rugged::Patch
  include ::Enumerable

  # Returns the number of additions in the patch.
  #
  # source://rugged//lib/rugged/patch.rb#22
  def additions; end

  def bytesize(*_arg0); end

  # Returns the number of total changes in the patch.
  #
  # source://rugged//lib/rugged/patch.rb#32
  def changes; end

  def count; end

  # Returns the number of deletions in the patch.
  #
  # source://rugged//lib/rugged/patch.rb#27
  def deletions; end

  def delta; end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/patch.rb#14
  def diff; end

  def each; end
  def each_hunk; end
  def header; end
  def hunk_count; end

  # Returns an Array containing all hunks of the patch.
  #
  # source://rugged//lib/rugged/patch.rb#37
  def hunks; end

  # source://rugged//lib/rugged/patch.rb#17
  def inspect; end

  def lines(*_arg0); end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/patch.rb#14
  def owner; end

  # Sets the attribute owner
  #
  # @param value the value to set the attribute owner to.
  #
  # source://rugged//lib/rugged/patch.rb#14
  def owner=(_arg0); end

  def size; end
  def stat; end
  def to_s; end

  class << self
    def from_strings(*_arg0); end
  end
end

class Rugged::PathError < ::Rugged::Error; end

class Rugged::Rebase
  def abort; end
  def commit(*_arg0); end
  def finish(_arg0); end
  def inmemory_index; end
  def next; end

  class << self
    def new(*_arg0); end
  end
end

class Rugged::RebaseError < ::Rugged::Error; end

# source://rugged//lib/rugged/reference.rb#7
class Rugged::Reference
  def branch?; end
  def canonical_name; end

  # source://rugged//lib/rugged/reference.rb#8
  def inspect; end

  def log; end
  def log?; end
  def name; end
  def peel; end
  def remote?; end
  def resolve; end
  def tag?; end
  def target; end
  def target_id; end
  def type; end

  class << self
    def valid_name?(_arg0); end
  end
end

class Rugged::ReferenceCollection
  include ::Enumerable

  def initialize(_arg0); end

  def [](_arg0); end
  def create(*_arg0); end
  def delete(_arg0); end
  def each(*_arg0); end
  def each_name(*_arg0); end
  def exist?(_arg0); end
  def exists?(_arg0); end
  def move(*_arg0); end
  def rename(*_arg0); end
  def update(*_arg0); end
end

class Rugged::ReferenceError < ::Rugged::Error; end
class Rugged::RegexError < ::Rugged::Error; end

# source://rugged//lib/rugged/remote.rb#7
class Rugged::Remote
  def check_connection(*_arg0); end
  def fetch(*_arg0); end
  def fetch_refspecs; end
  def ls(*_arg0); end
  def name; end
  def push(*_arg0); end
  def push_refspecs; end
  def push_url; end
  def push_url=(_arg0); end
  def url; end
end

class Rugged::RemoteCollection
  include ::Enumerable

  def initialize(_arg0); end

  def [](_arg0); end
  def add_fetch_refspec(_arg0, _arg1); end
  def add_push_refspec(_arg0, _arg1); end
  def create(_arg0, _arg1); end
  def create_anonymous(_arg0); end
  def delete(_arg0); end
  def each; end
  def each_name; end
  def rename(_arg0, _arg1); end
  def set_push_url(_arg0, _arg1); end
  def set_url(_arg0, _arg1); end
end

# Repository is an interface into a Git repository on-disk. It's the primary
# interface between your app and the main Git objects Rugged makes available
# to you.
#
# source://rugged//lib/rugged/repository.rb#10
class Rugged::Repository
  def ahead_behind(_arg0, _arg1); end
  def apply(*_arg0); end

  # source://rugged//lib/rugged/attributes.rb#8
  def attributes(path, options = T.unsafe(nil)); end

  def bare?; end

  # Get the blob at a path for a specific revision.
  #
  # revision - The String SHA1.
  # path     - The String file path.
  #
  # Returns a Rugged::Blob object
  #
  # source://rugged//lib/rugged/repository.rb#242
  def blob_at(revision, path); end

  # All the branches in the repository
  #
  # Returns a BranchCollection containing Rugged::Branch objects
  #
  # source://rugged//lib/rugged/repository.rb#207
  def branches; end

  # Checkout the specified branch, reference or commit.
  #
  # target - A revparse spec for the branch, reference or commit to check out.
  # options - Options passed to #checkout_tree.
  #
  # source://rugged//lib/rugged/repository.rb#29
  def checkout(target, options = T.unsafe(nil)); end

  def checkout_head(*_arg0); end
  def checkout_index(*_arg0); end
  def checkout_tree(*_arg0); end
  def cherrypick(*_arg0); end
  def cherrypick_commit(*_arg0); end
  def close; end
  def config; end
  def config=(_arg0); end

  # Create a new branch in the repository
  #
  # name - The name of the branch (without a full reference path)
  # sha_or_ref - The target of the branch; either a String representing
  # an OID or a reference name, or a Rugged::Object instance.
  #
  # Returns a Rugged::Branch object
  #
  # source://rugged//lib/rugged/repository.rb#225
  def create_branch(name, sha_or_ref = T.unsafe(nil)); end

  def default_notes_ref; end
  def default_signature; end
  def descendant_of?(_arg0, _arg1); end

  # source://rugged//lib/rugged/repository.rb#99
  def diff(left, right, opts = T.unsafe(nil)); end

  def diff_from_buffer(_arg0); end

  # source://rugged//lib/rugged/repository.rb#118
  def diff_workdir(left, opts = T.unsafe(nil)); end

  def each_id; end
  def each_note(*_arg0); end
  def empty?; end
  def exists?(_arg0); end
  def expand_oids(*_arg0); end

  # source://rugged//lib/rugged/repository.rb#253
  def fetch(remote_or_url, *args, **kwargs); end

  def fetch_attributes(*_arg0); end
  def head; end
  def head=(_arg0); end
  def head_detached?; end
  def head_unborn?; end
  def ident; end
  def ident=(_arg0); end
  def include?(_arg0); end
  def index; end
  def index=(_arg0); end

  # Pretty formatting of a Repository.
  #
  # Returns a very pretty String.
  #
  # source://rugged//lib/rugged/repository.rb#14
  def inspect; end

  # Get the most recent commit from this repo.
  #
  # Returns a Rugged::Commit object.
  #
  # source://rugged//lib/rugged/repository.rb#21
  def last_commit; end

  # Look up a SHA1.
  #
  # Returns one of the four classes that inherit from Rugged::Object.
  #
  # source://rugged//lib/rugged/repository.rb#146
  def lookup(oid); end

  def merge_analysis(*_arg0); end
  def merge_base(*_arg0); end
  def merge_bases(*_arg0); end
  def merge_commits(*_arg0); end
  def namespace; end
  def namespace=(_arg0); end
  def path; end
  def path_ignored?(_arg0); end

  # Push a list of refspecs to the given remote.
  #
  # refspecs - A list of refspecs that should be pushed to the remote.
  #
  # Returns a hash containing the pushed refspecs as keys and
  # any error messages or +nil+ as values.
  #
  # source://rugged//lib/rugged/repository.rb#266
  def push(remote_or_url, *args, **kwargs); end

  def read(_arg0); end
  def read_header(_arg0); end

  # Look up a single reference by name.
  #
  # Example:
  #
  #   repo.ref 'refs/heads/master'
  #   # => #<Rugged::Reference:2199125780 {name: "refs/heads/master",
  #          target: "25b5d3b40c4eadda8098172b26c68cf151109799"}>
  #
  # Returns a Rugged::Reference.
  #
  # source://rugged//lib/rugged/repository.rb#173
  def ref(ref_name); end

  # source://rugged//lib/rugged/repository.rb#185
  def ref_names(glob = T.unsafe(nil)); end

  # source://rugged//lib/rugged/repository.rb#181
  def references; end

  # source://rugged//lib/rugged/repository.rb#177
  def refs(glob = T.unsafe(nil)); end

  # All the remotes in the repository.
  #
  # Returns a Rugged::RemoteCollection containing all the Rugged::Remote objects
  # in the repository.
  #
  # source://rugged//lib/rugged/repository.rb#200
  def remotes; end

  def reset(_arg0, _arg1); end
  def reset_path(*_arg0); end

  # Look up an object by a revision string.
  #
  # Returns one of the four classes that inherit from Rugged::Object.
  #
  # source://rugged//lib/rugged/repository.rb#153
  def rev_parse(spec); end

  # Look up an object by a revision string.
  #
  # Returns the oid of the matched object as a String
  #
  # source://rugged//lib/rugged/repository.rb#160
  def rev_parse_oid(spec); end

  def revert_commit(*_arg0); end
  def shallow?; end

  # call-seq:
  #    repo.status { |file, status_data| block }
  #    repo.status(path) -> status_data
  #
  #  Returns the status for one or more files in the working directory
  #  of the repository. This is equivalent to the +git status+ command.
  #
  #  The returned +status_data+ is always an array containing one or more
  #  status flags as Ruby symbols. Possible flags are:
  #
  #  - +:index_new+: the file is new in the index
  #  - +:index_modified+: the file has been modified in the index
  #  - +:index_deleted+: the file has been deleted from the index
  #  - +:worktree_new+: the file is new in the working directory
  #  - +:worktree_modified+: the file has been modified in the working directory
  #  - +:worktree_deleted+: the file has been deleted from the working directory
  #
  #  If a +block+ is given, status information will be gathered for every
  #  single file on the working dir. The +block+ will be called with the
  #  status data for each file.
  #
  #    repo.status { |file, status_data| puts "#{file} has status: #{status_data.inspect}" }
  #
  #  results in, for example:
  #
  #    src/diff.c has status: [:index_new, :worktree_new]
  #    README has status: [:worktree_modified]
  #
  #  If a +path+ is given instead, the function will return the +status_data+ for
  #  the file pointed to by path, or raise an exception if the path doesn't exist.
  #
  #  +path+ must be relative to the repository's working directory.
  #
  #    repo.status('src/diff.c') #=> [:index_new, :worktree_new]
  #
  # source://rugged//lib/rugged/repository.rb#91
  def status(file = T.unsafe(nil), &block); end

  # All the submodules in the repository
  #
  # Returns a SubmoduleCollection containing Rugged::Submodule objects
  #
  # source://rugged//lib/rugged/repository.rb#214
  def submodules; end

  # All the tags in the repository.
  #
  # Returns a TagCollection containing all the tags.
  #
  # source://rugged//lib/rugged/repository.rb#192
  def tags; end

  # Walks over a set of commits using Rugged::Walker.
  #
  # from    - The String SHA1 to push onto Walker to begin our walk.
  # sorting - The sorting order of the commits, as defined in the README.
  # block   - A block that we pass into walker#each.
  #
  # Returns nothing if called with a block, otherwise returns an instance of
  # Enumerable::Enumerator containing Rugged::Commit objects.
  #
  # source://rugged//lib/rugged/repository.rb#136
  def walk(from, sorting = T.unsafe(nil), &block); end

  def workdir; end
  def workdir=(_arg0); end
  def write(_arg0, _arg1); end

  private

  def each_status; end
  def file_status(_arg0); end

  class << self
    def bare(*_arg0); end
    def clone_at(*_arg0); end
    def discover(*_arg0); end
    def hash_data(_arg0, _arg1); end
    def hash_file(_arg0, _arg1); end
    def init_at(*_arg0); end
    def new(*_arg0); end
  end
end

# source://rugged//lib/rugged/attributes.rb#12
class Rugged::Repository::Attributes
  include ::Enumerable

  # @return [Attributes] a new instance of Attributes
  #
  # source://rugged//lib/rugged/attributes.rb#27
  def initialize(repository, path, options = T.unsafe(nil)); end

  # source://rugged//lib/rugged/attributes.rb#33
  def [](attribute); end

  # source://rugged//lib/rugged/attributes.rb#41
  def each(&block); end

  # source://rugged//lib/rugged/attributes.rb#37
  def to_h; end

  class << self
    # source://rugged//lib/rugged/attributes.rb#21
    def parse_opts(opt); end
  end
end

# source://rugged//lib/rugged/attributes.rb#15
Rugged::Repository::Attributes::LOAD_PRIORITIES = T.let(T.unsafe(nil), Hash)

class Rugged::RepositoryError < ::Rugged::Error; end
class Rugged::RevertError < ::Rugged::Error; end
class Rugged::SHA1Error < ::Rugged::Error; end
Rugged::SORT_DATE = T.let(T.unsafe(nil), Integer)
Rugged::SORT_NONE = T.let(T.unsafe(nil), Integer)
Rugged::SORT_REVERSE = T.let(T.unsafe(nil), Integer)
Rugged::SORT_TOPO = T.let(T.unsafe(nil), Integer)

class Rugged::Settings
  private

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def max_cache_size; end
  def used_cache_size; end

  class << self
    def [](_arg0); end
    def []=(_arg0, _arg1); end
    def max_cache_size; end
    def used_cache_size; end
  end
end

class Rugged::SshError < ::Rugged::Error; end
class Rugged::SslError < ::Rugged::Error; end
class Rugged::StashError < ::Rugged::Error; end

class Rugged::Submodule
  def add_to_index(*_arg0); end
  def added_to_index?; end
  def added_to_workdir?; end
  def deleted_from_index?; end
  def deleted_from_workdir?; end
  def dirty_workdir?; end
  def dirty_workdir_index?; end
  def fetch_recurse_submodules?; end
  def finalize_add; end
  def head_oid; end
  def ignore_rule; end
  def in_config?; end
  def in_head?; end
  def in_index?; end
  def in_workdir?; end
  def index_oid; end
  def init(*_arg0); end
  def modified_files_in_workdir?; end
  def modified_in_index?; end
  def modified_in_workdir?; end
  def name; end
  def path; end
  def reload; end
  def repository; end
  def status; end
  def sync; end
  def uninitialized?; end
  def unmodified?; end
  def untracked_files_in_workdir?; end
  def update_rule; end
  def url; end
  def workdir_oid; end
end

# source://rugged//lib/rugged/submodule_collection.rb#7
class Rugged::SubmoduleCollection
  include ::Enumerable

  def initialize(_arg0); end

  def [](_arg0); end

  # call-seq:
  #   submodules.setup_add(url, path[, options]) -> submodule
  #
  # Add a new +submodule+.
  #
  # This does <tt>"git submodule add"</tt> incuding fetch and checkout of the
  # submodule contents.
  #
  # - +url+: URL for the submodule's remote
  # - +path+: path at which the submodule should be created
  #
  # The +options+ hash accepts all options supported by Rugged::Remote#fetch
  # and the following:
  # :gitlink ::
  #   (defaults to +true+) should workdir contain a
  #   gitlink to the repository in +.git/modules+ vs. repository
  #   directly in workdir.
  #
  # Returns the newly created +submodule+
  #
  # source://rugged//lib/rugged/submodule_collection.rb#28
  def add(url, path, options = T.unsafe(nil)); end

  def each; end
  def setup_add(*_arg0); end
  def update(_arg0, _arg1); end

  private

  # currently libgit2's `git_submodule_add_setup` initializes a repo
  # with a workdir for the submodule. libgit2's `git_clone` however
  # requires the target for the clone to be an empty dir.
  #
  # This provides a ghetto clone implementation that:
  # 1. fetches the remote
  # 2. sets up a master branch to be tracking origin/master
  # 3. checkouts the submodule
  #
  # source://rugged//lib/rugged/submodule_collection.rb#43
  def clone_submodule(repo, **fetch_options); end
end

class Rugged::SubmoduleError < ::Rugged::Error; end

# source://rugged//lib/rugged/tag.rb#7
class Rugged::Tag < ::Rugged::Reference
  def annotated?; end
  def annotation; end

  # source://rugged//lib/rugged/tag.rb#27
  def name; end

  def target; end

  class << self
    # source://rugged//lib/rugged/tag.rb#10
    def extract_signature(repo, oid, prefix = T.unsafe(nil)); end
  end
end

# source://rugged//lib/rugged/tag.rb#31
class Rugged::Tag::Annotation < ::Rugged::Object
  # source://rugged//lib/rugged/tag.rb#36
  def inspect; end

  def message; end

  # source://rugged//lib/rugged/tag.rb#49
  def modify(new_args, force = T.unsafe(nil)); end

  def name; end
  def tagger; end
  def target; end
  def target_id; end
  def target_oid; end
  def target_type; end

  # source://rugged//lib/rugged/tag.rb#40
  def to_hash; end

  class << self
    # source://rugged//lib/rugged/tag.rb#32
    def prettify_message(msg, strip_comments = T.unsafe(nil)); end
  end
end

# source://rugged//lib/rugged/tag.rb#8
Rugged::Tag::GPG_SIGNATURE_PREFIX = T.let(T.unsafe(nil), String)

class Rugged::TagCollection
  include ::Enumerable

  def initialize(_arg0); end

  def [](_arg0); end
  def create(*_arg0); end
  def create_annotation(_arg0, _arg1, _arg2); end
  def delete(_arg0); end
  def each(*_arg0); end
  def each_name(*_arg0); end
end

class Rugged::TagError < ::Rugged::Error; end
class Rugged::ThreadError < ::Rugged::Error; end

# source://rugged//lib/rugged/tree.rb#7
class Rugged::Tree < ::Rugged::Object
  include ::Enumerable

  def [](_arg0); end
  def count; end
  def count_recursive(*_arg0); end

  # source://rugged//lib/rugged/tree.rb#163
  def diff(other = T.unsafe(nil), options = T.unsafe(nil)); end

  def diff_workdir(*_arg0); end
  def each; end

  # Iterate over the blobs in this tree
  #
  # source://rugged//lib/rugged/tree.rb#186
  def each_blob; end

  # Iterate over the subtrees in this tree
  #
  # source://rugged//lib/rugged/tree.rb#192
  def each_tree; end

  def get_entry(_arg0); end
  def get_entry_by_oid(_arg0); end

  # source://rugged//lib/rugged/tree.rb#167
  def inspect; end

  def length; end
  def merge(*_arg0); end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/tree.rb#160
  def owner; end

  def path(_arg0); end

  # Returns the value of attribute owner.
  #
  # source://rugged//lib/rugged/tree.rb#160
  def repo; end

  def update(_arg0); end
  def walk(_arg0); end

  # Walks the tree but only yields blobs
  #
  # source://rugged//lib/rugged/tree.rb#174
  def walk_blobs(mode = T.unsafe(nil)); end

  # Walks the tree but only yields subtrees
  #
  # source://rugged//lib/rugged/tree.rb#180
  def walk_trees(mode = T.unsafe(nil)); end

  class << self
    # call-seq:
    #   Tree.diff(repo, tree, diffable[, options]) -> diff
    #
    # Returns a diff between the `tree` and the diffable object that was given.
    # +diffable+ can either be a +Rugged::Commit+, a +Rugged::Tree+, a +Rugged::Index+,
    # or +nil+.
    #
    # The +tree+ object will be used as the "old file" side of the diff, while the
    # parent tree or the +diffable+ object will be used for the "new file" side.
    #
    # If +tree+ or +diffable+ are nil, they will be treated as an empty tree. Passing
    # both as `nil` will raise an exception.
    #
    # The following options can be passed in the +options+ Hash:
    #
    # :paths ::
    #   An array of paths / fnmatch patterns to constrain the diff to a specific
    #   set of files. Also see +:disable_pathspec_match+.
    #
    # :max_size ::
    #   An integer specifying the maximum byte size of a file before a it will
    #   be treated as binary. The default value is 512MB.
    #
    # :context_lines ::
    #   The number of unchanged lines that define the boundary of a hunk (and
    #   to display before and after the actual changes). The default is 3.
    #
    # :interhunk_lines ::
    #   The maximum number of unchanged lines between hunk boundaries before the hunks
    #   will be merged into a one. The default is 0.
    #
    # :old_prefix ::
    #   The virtual "directory" to prefix to old filenames in hunk headers.
    #   The default is "a".
    #
    # :new_prefix ::
    #   The virtual "directory" to prefix to new filenames in hunk headers.
    #   The default is "b".
    #
    # :reverse ::
    #   If true, the sides of the diff will be reversed.
    #
    # :force_text ::
    #   If true, all files will be treated as text, disabling binary attributes & detection.
    #
    # :ignore_whitespace ::
    #   If true, all whitespace will be ignored.
    #
    # :ignore_whitespace_change ::
    #   If true, changes in amount of whitespace will be ignored.
    #
    # :ignore_whitespace_eol ::
    #   If true, whitespace at end of line will be ignored.
    #
    # :ignore_submodules ::
    #   if true, submodules will be excluded from the diff completely.
    #
    # :patience ::
    #   If true, the "patience diff" algorithm will be used (currenlty unimplemented).
    #
    # :include_ignored ::
    #   If true, ignored files will be included in the diff.
    #
    # :include_untracked ::
    #  If true, untracked files will be included in the diff.
    #
    # :include_unmodified ::
    #   If true, unmodified files will be included in the diff.
    #
    # :recurse_untracked_dirs ::
    #   Even if +:include_untracked+ is true, untracked directories will only be
    #   marked with a single entry in the diff. If this flag is set to true,
    #   all files under ignored directories will be included in the diff, too.
    #
    # :disable_pathspec_match ::
    #   If true, the given +:paths+ will be applied as exact matches, instead of
    #   as fnmatch patterns.
    #
    # :deltas_are_icase ::
    #   If true, filename comparisons will be made with case-insensitivity.
    #
    # :show_untracked_content ::
    #   if true, untracked content will be contained in the the diff patch text.
    #
    # :skip_binary_check ::
    #   If true, diff deltas will be generated without spending time on binary
    #   detection. This is useful to improve performance in cases where the actual
    #   file content difference is not needed.
    #
    # :include_typechange ::
    #   If true, type changes for files will not be interpreted as deletion of
    #   the "old file" and addition of the "new file", but will generate
    #   typechange records.
    #
    # :include_typechange_trees ::
    #   Even if +:include_typechange+ is true, blob -> tree changes will still
    #   usually be handled as a deletion of the blob. If this flag is set to true,
    #   blob -> tree changes will be marked as typechanges.
    #
    # :ignore_filemode ::
    #   If true, file mode changes will be ignored.
    #
    # :recurse_ignored_dirs ::
    #   Even if +:include_ignored+ is true, ignored directories will only be
    #   marked with a single entry in the diff. If this flag is set to true,
    #   all files under ignored directories will be included in the diff, too.
    #
    # Examples:
    #
    #   # Emulating `git diff <treeish>`
    #   tree = Rugged::Tree.lookup(repo, "d70d245ed97ed2aa596dd1af6536e4bfdb047b69")
    #   diff = tree.diff(repo.index)
    #   diff.merge!(tree.diff)
    #
    #   # Tree-to-Tree Diff
    #   tree = Rugged::Tree.lookup(repo, "d70d245ed97ed2aa596dd1af6536e4bfdb047b69")
    #   other_tree = Rugged::Tree.lookup(repo, "7a9e0b02e63179929fed24f0a3e0f19168114d10")
    #   diff = tree.diff(other_tree)
    #
    # source://rugged//lib/rugged/tree.rb#129
    def diff(repo, tree, other_tree = T.unsafe(nil), options = T.unsafe(nil)); end

    def empty(_arg0); end

    private

    def diff_tree_to_index(_arg0, _arg1, _arg2, _arg3); end
    def diff_tree_to_tree(_arg0, _arg1, _arg2, _arg3); end
  end
end

class Rugged::Tree::Builder
  def <<(_arg0); end
  def [](_arg0); end
  def clear; end
  def insert(_arg0); end
  def reject!; end
  def remove(_arg0); end
  def write; end

  class << self
    def new(*_arg0); end
  end
end

class Rugged::TreeError < ::Rugged::Error; end

# source://rugged//lib/rugged/version.rb#7
Rugged::VERSION = T.let(T.unsafe(nil), String)

# source://rugged//lib/rugged/version.rb#7
Rugged::Version = T.let(T.unsafe(nil), String)

# source://rugged//lib/rugged/walker.rb#7
class Rugged::Walker
  include ::Enumerable

  def count(*_arg0); end
  def each(*_arg0); end
  def each_oid(*_arg0); end
  def hide(_arg0); end
  def push(_arg0); end
  def push_range(_arg0); end
  def reset; end
  def simplify_first_parent; end
  def sorting(_arg0); end
  def walk(*_arg0); end

  class << self
    def new(_arg0); end
    def walk(*_arg0); end
  end
end

class Rugged::WorktreeError < ::Rugged::Error; end
class Rugged::ZlibError < ::Rugged::Error; end
